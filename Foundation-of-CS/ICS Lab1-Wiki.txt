{{DISPLAYTITLE:LAB1 - 数据表示实验}}

{{lab|实验提交(请认真阅读以下内容, 若有违反, 后果自负)|

<u>'''截止时间: 见[http://114.212.10.9/cms 计算机系实验教学中心课程管理系统]上的相应作业发布信息。如无特殊原因, 迟交实验报告将损失50%的成绩(即使迟了1秒), 请大家合理分配时间''' </u>

<u>'''学术诚信'''</u>: 如果你确实无法完成实验, 你可以选择不提交.

<u>'''提交方式'''</u>: 待定

<u>'''提交地址'''</u>: 待定

<u>'''提交格式'''</u>: 待定

<u>'''请你在实验截止前务必确认你提交的内容符合要求(格式, 相关内容等), 你可以下载你提交的内容进行确认. 如果由于你的原因给我们造成了不必要的麻烦, 视情况而定, 在本次实验中你将会被扣除一定的分数, 最高可达50%.'''</u>
}}


== 简介 ==

本实验的目的是更好地熟悉和掌握计算机中整数和浮点数的二进制编码表示。实验中，你需要解开一系列编程“难题”――使用有限类型和数量的运算操作实现一组给定功能的函数，在此过程中你将加深对数据二进制编码表示的了解。

实验语言：c； 实验环境： linux

== 实验数据与结果提交 ==

实验所需要的代码和相关文件已打包成一个ZIP文件（[[File:ICS-lab1.zip]]）供下载，其中包含下列文件：
* README ―― 有关实验细节的说明文件，请在开始实验前仔细阅读
* bits.c ―― 包含一组用于完成指定功能的函数的代码框架，需要你按要求补充完成其函数体代码并“作为实验结果提交”。函数的功能与实现要求详细说明在相应函数和文件首部的注释中（务必认真阅读和遵照说明完成实验）。
** bits.h ―― 头文件
* btest.c ―― 实验结果测试工具，用于检查作为实验结果的 bits.c中函数实现是否满足实验的功能正确性要求。
** btest.h, decl.c, tests.c ―― 生成btest程序的源文件
* dlc ―― 实验结果检查工具，用于判断作为实验结果的 bits.c中函数实现是否满足实验的语法规则要求。
* Makefile ―― 生成btest、fshow、ishow等工具的Make文件。
* ishow.c ―― 整型数据表示查看工具
* fshow.c ―― 浮点数据表示查看工具

请将完成函数体代码后的bits.c作为实验结果提交。

== 实验要求 ==

实验前请认真阅读本文档和bits.c中的代码及注释，然后根据要求相应完成bits.c中的各函数代码。

实验中实现的函数代码必须满足下述基本条件（更多具体要求见函数的注释）：
* 除关于浮点数的函数实现外，只能使用顺序程序结构（不得使用循环或条件分支控制程序结构，例如if, do, while, for, switch等）。
* 仅能使用有限类型和数量的C语言算术和逻辑操作，例如如下的操作符，但注意每个题目可能有不同的可用操作符列表，详见具体函数说明。
<nowiki> ！ ~  &  ^  |  +  <<  >> </nowiki>
* 不得使用超过8位表示的常量（即其值必须位于[0,255]中）。
* 不得使用任何形式的强制类型转换。
* 不得使用除整型外的任何其它数据类型，如数组、结构、联合等。
* 不得定义和使用宏。
* 不得定义除已给定的框架函数外的其他函数，不得调用任何函数。
* 特定于浮点数操作函数的额外限制条件：
** 可以使用循环和条件控制；
** 可以使用整型和无符号整型常量及变量（取值不受[0,255]限制）；
** 不使用任何浮点数据类型、操作及常量。

上述实验要求的主要目的是使得你必须从二进制位的角度考虑数据，进而更清楚地理解数据的二进制表示。

== 问题描述 ==

你需要完成bits.c中下列函数功能，具体分为三大类：位操作、补码运算和浮点数操作。

<!--
{{lab|注意：|
* 关于浮点数的函数实现可以使用标准的程序结构(选择、循环均可使用)，可以使用int和unsigned两种整形数据，不得使用浮点数据类型、struct、union或数组结构。关于浮点数的函数均使用unsigned型数据表示浮点数据。
* float_neg和float_twice等函数必须能处理全范围的变量值，包括(NaN)和infinity.为简化问题，若要返回NaN值，可使用0x7FC0000表示。
* 具体的函数功能和实现要求可参看bits.c各函数框架的注释，以注释为准。
}}
-->

一）位操作：

下表列出了bits.c中一组操作和测试位组的函数。其中，“级别”栏指出各函数的难度等级（对应于该函数的实验分值），“功能”栏给出函数应实现的输出（即功能），“约束条件”栏指出你的函数实现必须满足的编码规则（具体请查看bits.c中相应函数注释），“最多操作符数量”指出你的函数实现中允许使用的操作符（如|和~）的最大数量。
你也可参考tests.c中对应的测试函数来了解所需实现的功能，但是注意这些测试函数并不满足目标函数必须遵循的编码约束条件，只能用做关于目标函数正确行为的参考。

{| class="wikitable"
|+题目列表
! 级别
! 函数名
! 功能
! 约束条件
! 最多操作符数量
|-
|1
|bitAnd(x,y)
|<nowiki>x & y</nowiki>
|<nowiki>仅能使用|和~</nowiki>
|8
|-
|1
|bitXor(x,y)
|<nowiki>x ^ y</nowiki>
|<nowiki>仅能使用&和~</nowiki>
|14
|-
|1
|thirdBits()
|<nowiki>返回一个32位整型字，使其自最低有效位LSB起每三个位组的最低位置1，其它位置0（即...001001001）</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|8
|-
|2
|getByte(x,n)
|<nowiki>从32位字x中提取第n字节（字节从LSB开始到MSB依次编号为0-3）</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|6
|-
|3
|logicalShift(x,n)
|<nowiki>使用逻辑移位操作将x右移n位（假设0 <= n <= 31）</nowiki>
|<nowiki>仅能使用~，&，^，|，+，<<，>></nowiki>
|20
|-
|4
|bang(x)
|<nowiki>!x</nowiki>
|<nowiki>仅能使用~，&，^，|，+，<<，>></nowiki>
|12
|-
|3
|conditional(x,y,z)
|<nowiki>x ? y : z</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|16
|}

二）补码运算：

下表列出了bits.c中一组使用整数的补码表示的函数。可参考bits.c中注释说明和tests.c中对应的测试函数了解其更多具体信息。

{| class="wikitable"
|+题目列表
! 级别
! 函数名
! 功能
! 约束条件
! 最多操作符数量
|-
|2
|fitsBits(x,n)
|<nowiki>如果x可表示为一个n位补码整数则返回1，否则返回0</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|15
|-
|2
|sign(x)
|<nowiki>返回1――x是正数，0――x为0，或者-1――x是负数</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|10
|-
|3
|addOK(x,y)
|<nowiki>如果计算x+y不发生溢出则返回1，否则返回0</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|20
|-
|4
|isPower2(x)
|<nowiki>如果x是2的指数返回1，否则返回0</nowiki>
|<nowiki>仅能使用!，~，&，^，|，+，<<，>></nowiki>
|20
|}

三）浮点数操作：

下表列出了bits.c中一组浮点数二进制表示的操作函数。可参考bits.c中注释说明和tests.c中对应的测试函数了解其更多具体信息。

注意float_neg和float_twice函数的输入参数和返回结果（以及float_i2f函数的返回结果）均为unsigned int类型，但应作为单精度浮点数解释其32 bit二进制表示对应的值。

{| class="wikitable"
|+题目列表
! 级别
! 函数名
! 功能
! 约束条件
! 最多操作符数量
|-
|2
|float_neg(f)
|<nowiki>返回浮点数'-f'的二进制表示。当输入参数是NaN时，返回NaN</nowiki>
|<nowiki>仅能使用任何整型/无符号整型操作，包括||，&&以及if，while控制结构</nowiki>
|10
|-
|4
|float_i2f(x)
|<nowiki>返回整型输入x的强制浮点类型转换“(float) x”结果的二进制表示</nowiki>
|<nowiki>仅能使用任何整型/无符号整型操作，包括||，&&以及if，while控制结构</nowiki>
|30
|-
|4
|float_twice(f)
|<nowiki>返回浮点数'2*f'的二进制表示。当输入参数是NaN时，返回NaN</nowiki>
|<nowiki>仅能使用任何整型/无符号整型操作，包括||，&&以及if，while控制结构</nowiki>
|30
|}

== 检查你的代码 ==

如前所述，实验数据包中包含两个工具程序可帮助检查你的代码的正确性。

=== 使用dlc检查函数实现代码是否符合实验要求中的编码规则 ===

完成bits.c后，调用如下命令进行检查：
 $ ./dlc bits.c
dlc将返回错误信息如果它发现了错误，例如不允许使用的操作符、过多数量的操作符或者非顺序的代码结构。如果程序代码满足规则要求，dlc将不输出任何提示。

使用-e选项调用dlc
 $ ./dlc -e bits.c
可使dlc打印出每个函数使用的操作符数量。

输入“ ./dlc -help”可打印出dlc的可用命令行选项列表。

=== 使用btest检查函数实现代码的功能正确性 ===

首先使用如下命令编译生成btest可执行程序：
 $ make
 
如下调用btest命令检查bits.c中所有函数的功能正确性：
 $ ./btest

注意每次修改bits.c后都必须使用make命令重新编译生成btest程序。

为方便依次检查测试每一函数的正确性，可如下在命令行使用“-f”选项跟上函数名，以要求btest只测试所指定的函数：
 $ ./btest -f bitXor
 
进一步可如下使用“-1, -2, -3”等选项在函数名后输入特定的函数参数：
 $ ./btest -f bitXor -1 7 -2 0xf

（README文件中有关于btest程序的使用说明）

== 建议与提示 ==

# 如果你的代码不能完全满足相应函数的操作符使用限制，你可以获得部分得分，但是往往这样的次优解总能找到改进它的方法，从而获得正确解答。
# 在bits.c文件中不要包含<stdio.h>头文件，因为这样将给dlc程序造成困难并产生一些难以理解的错误信息。注意尽管未包含<stdio.h>头文件，你仍然可以在bits.c中调用printf函数进行调试，gcc将打印警告信息但你可以忽略它们。
# 注意dlc程序使用比gcc和C++更严格的C变量声明形式。在由“{}”包围的一个代码块中，所有变量声明必须出现在任何非声明语句之前。例如，针对下述代码，dlc将报错：
<syntaxhighlight lang=c>
int foo(int x)
{
    int a = x;
    a *= 3;     /* Statement that is not a declaration */
    int b = a;  /* ERROR: Declaration not allowed here */
}
</syntaxhighlight>
你必须类似如下代码将变量声明放在最前：
<syntaxhighlight lang=c>
int foo(int x)
{
    int a = x;
    int b;
    a *= 3;
    b = a;
}
</syntaxhighlight>
